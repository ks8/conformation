""" Compare two sets of conformations generated by different conformational search programs. """
import copy
from logging import Logger
import math
import numpy as np
from typing import List
from typing_extensions import Literal

from rdkit import Chem
from rdkit.Chem import AllChem, rdchem, rdMolAlign
import scipy.optimize
# noinspection PyPackageRequirements
from tap import Tap

from conformation.run_rmsd_pruning import rmsd_pruning


class Args(Tap):
    """
    System arguments.
    """
    group_comparison: bool = False  # Whether or not to do a group comparison; default is reference comparison
    group_conf_paths: List[str] = []  # List of RDKit binary file paths to conformations for group comparison
    reference_path: str = None  # Path to RDKit binary file containing reference set (group_comparison=False)
    generated_path: str = None  # Path to RDKit binary file containing comparison set (group_comparison=False)
    energy_difference_threshold: float = 0.001  # Error tolerance for comparing energy values
    rmsd_pruning_threshold: float = 0.01  # Error tolerance for pruning reference set energies (group_comparison=True)
    rmsd_func: Literal["GetBestRMS", "AlignMol"] = "GetBestRMS"  # RMSD computation options
    rmsd_recovery_fraction: List[float] = [0.1]  # Bottom fraction of energies to check for recovery via RMSD
    energy_recovery_fraction: List[float] = [0.5]  # Bottom fraction of energies to check for recovery via energy
    rmsd_threshold: List[float] = [0.5]  # RMSD threshold applied
    rmsd_remove_Hs: bool = False  # Whether or not to remove Hydrogen when computing RMSD
    save_dir: str  # Save path for output files


# noinspection PyUnresolvedReferences
def reference_comparison(mol_reference: rdchem.Mol, reference_energies: List, mol_comparison: rdchem.Mol,
                         args: Args) -> List:
    """
    Compare two sets of conformations.
    :param mol_reference: Reference conformations.
    :param reference_energies: Reference energies.
    :param mol_comparison: Comparison conformations.
    :param args: System arguments.
    :return: List of results.
    """
    results = []

    mol_reference_no_hs = Chem.RemoveHs(mol_reference)
    mol_comparison_no_hs = Chem.RemoveHs(mol_comparison)

    results.append(mol_comparison.GetNumConformers())

    comparison_energies = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol_comparison, maxIters=0, numThreads=0)
    for i in range(len(res)):
        comparison_energies.append(res[i][1])

    if abs(min(reference_energies) - min(comparison_energies)) < args.energy_difference_threshold:
        results.append(True)
    else:
        results.append(False)

    comparison_results = []
    for comparison_threshold in args.energy_recovery_fraction:
        sorted_indices = sorted(range(len(reference_energies)), key=lambda k: reference_energies[k])
        fraction_indices = sorted_indices[:math.ceil(comparison_threshold * len(sorted_indices))]
        fraction_energies = [reference_energies[i] for i in fraction_indices]
        num = 0
        for i in range(len(fraction_energies)):
            for j in range(len(comparison_energies)):
                if abs(comparison_energies[j] - fraction_energies[i]) < args.energy_difference_threshold:
                    num += 1
                    break
        comparison_results.append((num / len(fraction_energies)*100.0))
    results.append(comparison_results)

    # Sort the energies and take the relevant fraction
    for fraction in args.rmsd_recovery_fraction:
        sorted_indices = sorted(range(len(reference_energies)), key=lambda k: reference_energies[k])
        fraction_indices = sorted_indices[:math.ceil(fraction * len(sorted_indices))]

        # Compute RMSD cost matrix between reference conformations and comparison conformations
        cost_matrix = np.zeros([len(fraction_indices), mol_comparison.GetNumConformers()])
        for index, i in enumerate(fraction_indices):
            for j in range(mol_comparison.GetNumConformers()):
                if args.rmsd_remove_Hs:
                    rmsd = rdMolAlign.GetBestRMS(mol_comparison_no_hs, mol_reference_no_hs, j, i)
                else:
                    rmsd = rdMolAlign.GetBestRMS(mol_comparison, mol_reference, j, i)
                cost_matrix[index][j] = rmsd
        opt = scipy.optimize.linear_sum_assignment(cost_matrix)

        # Compute the fraction of recovered reference conformations within the comparison RMSD threshold(s):
        comparison_results = []
        for comparison_threshold in args.rmsd_threshold:
            num = 0
            for i in range(opt[0].shape[0]):
                if cost_matrix[opt[0][i], opt[1][i]] < comparison_threshold:
                    num += 1
            comparison_results.append((num / cost_matrix.shape[0])*100.0)

        results.append(comparison_results)

    return results


def compare_conformations(args: Args, logger: Logger):
    """
    Compare two sets of conformations generated by different conformational search programs.
    :param args: System arguments.
    :param logger: System logger.
    :return: None.
    """
    # Set up logger
    debug, info = logger.debug, logger.info

    debug(f'Loading conformations...')
    if args.group_comparison:
        conformation_sets = []
        for i in range(len(args.group_conf_paths)):
            # noinspection PyUnresolvedReferences
            conformation_sets.append(Chem.Mol(open(args.group_conf_paths[i], "rb").read()))
            debug(f'Conformation set {i} has {conformation_sets[i].GetNumConformers()} conformations')

        debug(f'Creating combined reference set...')
        mol_reference = copy.deepcopy(conformation_sets[0])
        count = mol_reference.GetNumConformers()
        for i in range(1, len(conformation_sets)):
            tmp = copy.deepcopy(conformation_sets[i])
            for j in range(tmp.GetNumConformers()):
                c = tmp.GetConformers()[j]
                c.SetId(count)
                mol_reference.AddConformer(c)
                count += 1

        reference_energies = []
        res = AllChem.MMFFOptimizeMoleculeConfs(mol_reference, maxIters=0, numThreads=0)
        for i in range(len(res)):
            reference_energies.append(res[i][1])

        # Remove clear duplicates from the reference set
        mol_reference = rmsd_pruning(mol_reference, reference_energies, args.rmsd_func, args.rmsd_remove_Hs,
                                     args.energy_difference_threshold, args.rmsd_pruning_threshold)

        debug(f'Combined reference set has {mol_reference.GetNumConformers()} conformations')
    else:
        # noinspection PyUnresolvedReferences
        conformation_sets = [Chem.Mol(open(args.generated_path, "rb").read())]
        # noinspection PyUnresolvedReferences
        mol_reference = Chem.Mol(open(args.reference_path, "rb").read())

    debug(f'Computing reference energies...')
    reference_energies = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol_reference, maxIters=0, numThreads=0)
    for i in range(len(res)):
        reference_energies.append(res[i][1])

    reference_energy_minimum = min(reference_energies)
    debug(f'The reference set global energy minimum is: {reference_energy_minimum} kcal/mol')
    debug(f'The reference energy fractions checked for energy recovery are: '
          f'{args.energy_recovery_fraction}')

    energy_recovery_values = []
    for comparison_threshold in args.energy_recovery_fraction:
        sorted_indices = sorted(range(len(reference_energies)), key=lambda k: reference_energies[k])
        fraction_indices = sorted_indices[:math.ceil(comparison_threshold * len(sorted_indices))]
        fraction_energies = [reference_energies[i] for i in fraction_indices]
        energy_recovery_values.append(fraction_energies[-1] - reference_energy_minimum)

    debug(f'The corresponding energy deviations from global minimum are (kcal/mol): {energy_recovery_values}')
    debug(f'The reference energy fractions checked for RMSD recovery are: {args.rmsd_recovery_fraction}')

    energy_recovery_values = []
    for comparison_threshold in args.rmsd_recovery_fraction:
        sorted_indices = sorted(range(len(reference_energies)), key=lambda k: reference_energies[k])
        fraction_indices = sorted_indices[:math.ceil(comparison_threshold * len(sorted_indices))]
        fraction_energies = [reference_energies[i] for i in fraction_indices]
        energy_recovery_values.append(fraction_energies[-1] - reference_energy_minimum)

    debug(f'The corresponding energy deviations from global minimum are (kcal/mol): {energy_recovery_values}')
    debug(f'The RMSD levels checked for recovery are (Angstrom): {args.rmsd_threshold}')

    for i in range(len(conformation_sets)):
        results = reference_comparison(mol_reference, reference_energies, conformation_sets[i], args)
        debug("\n")
        debug(f'Results for conformation set {i}: ')
        debug(f'Number of conformations: {results[0]}')
        debug(f'Global energy minimum recovered?: {results[1]}')
        debug(f'Percent energy recovery: {results[2]}')
        for index, j in enumerate(args.rmsd_recovery_fraction):
            debug(f'Percent RMSD recovery for bottom {j*100.0}% of energies: {results[3 + index]}')
        debug("\n")
