""" Compare two sets of conformations generated by different conformational search programs. """
import copy
from logging import Logger
import math
import matplotlib.pyplot as plt
import numpy as np
import os
import pandas as pd
from typing import List
from typing_extensions import Literal

from rdkit import Chem
from rdkit.Chem import AllChem, rdchem
import scipy.optimize
import seaborn as sns
# noinspection PyPackageRequirements
from tap import Tap
from tqdm import tqdm

from conformation.run_rmsd_pruning import compute_rmsd, rmsd_pruning


class Args(Tap):
    """
    System arguments.
    """
    group_comparison: bool = False  # Whether or not to do a group comparison; default is reference comparison
    group_conf_paths: List[str] = []  # List of RDKit binary file paths to conformations for group comparison
    group_conf_labels: List[str] = []  # List of method labels for plotting purposes
    reference_path: str = None  # Path to RDKit binary file containing reference set (group_comparison=False)
    generated_path: str = None  # Path to RDKit binary file containing comparison set (group_comparison=False)
    energy_difference_threshold: float = 0.001  # Error tolerance for comparing energy values
    rmsd_pruning_threshold: float = 0.01  # Error tolerance for pruning reference set energies (group_comparison=True)
    rmsd_func: Literal["GetBestRMS", "AlignMol"] = "GetBestRMS"  # RMSD computation options
    rmsd_recovery_fraction: List[float] = [0.1]  # Bottom fraction of energies to check for recovery via RMSD
    rmsd_threshold: List[float] = [0.5]  # RMSD threshold applied
    rmsd_remove_Hs: bool = False  # Whether or not to remove Hydrogen when computing RMSD
    temp: float = 300.0  # Temperature at which to compute Boltzmann probabilities.
    save_dir: str  # Save path for output files


# noinspection PyPep8Naming
def boltzmann_probability(energy: float, k_b: float, T: float, Z: float) -> float:
    """
    Compute the Boltzmann probability of a conformation.
    :param energy: Conformation energy (in Joules).
    :param k_b: Boltzmann constant (in cal/K).
    :param T: Temperature (in K).
    :param Z: Partition function.
    :return: Probability.
    """
    return math.exp(-energy/(k_b * T * 4.184))/Z


# noinspection PyUnresolvedReferences
def reference_comparison(mol_reference: rdchem.Mol, reference_energies: List, unique_reference_energies: List,
                         mol_comparison: rdchem.Mol, comparison_id: int, args: Args) -> List:
    """
    Compare two sets of conformations.
    :param mol_reference: Reference conformations.
    :param reference_energies: Reference energies.
    :param unique_reference_energies: Unique reference energies.
    :param mol_comparison: Comparison conformations.
    :param comparison_id: ID number for the comparison set.
    :param args: System arguments.
    :return: List of results.
    """
    results = []

    mol_reference_no_hs = Chem.RemoveHs(mol_reference)
    mol_comparison_no_hs = Chem.RemoveHs(mol_comparison)

    results.append(mol_comparison.GetNumConformers())

    comparison_energies = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol_comparison, maxIters=0, numThreads=0)
    for i in range(len(res)):
        comparison_energies.append(res[i][1])

    if abs(min(reference_energies) - min(comparison_energies)) < args.energy_difference_threshold:
        results.append(True)
    else:
        results.append(False)

    # Produce information for energy level plotting
    cost_matrix = np.zeros([len(unique_reference_energies), len(comparison_energies)])
    for i in range(len(unique_reference_energies)):
        for j in range(len(comparison_energies)):
            energy_diff = abs(comparison_energies[j] - unique_reference_energies[i])
            cost_matrix[i][j] = energy_diff
    opt = scipy.optimize.linear_sum_assignment(cost_matrix)

    discovered_energies = []
    discovered_indices = []
    for i in range(opt[0].shape[0]):
        if cost_matrix[opt[0][i], opt[1][i]] < args.energy_difference_threshold:
            discovered_energies.append([unique_reference_energies[opt[0][i]], "Found",
                                        args.group_conf_labels[comparison_id]])
            discovered_indices.append(opt[0][i])
    for i in range(len(unique_reference_energies)):
        if i not in discovered_indices:
            discovered_energies.append([unique_reference_energies[i], "Not Found",
                                        args.group_conf_labels[comparison_id]])
    results.append(discovered_energies)

    # Produce information for RMSD threshold comparisons
    for fraction in args.rmsd_recovery_fraction:
        sorted_indices = sorted(range(len(reference_energies)), key=lambda k: reference_energies[k])
        fraction_indices = sorted_indices[:math.ceil(fraction * len(sorted_indices))]

        # Compute RMSD cost matrix between reference conformations and comparison conformations
        cost_matrix = np.zeros([len(fraction_indices), mol_comparison.GetNumConformers()])
        for index, i in enumerate(fraction_indices):
            for j in range(mol_comparison.GetNumConformers()):
                if args.rmsd_remove_Hs:
                    rmsd = compute_rmsd(args.rmsd_func, mol_comparison_no_hs, mol_reference_no_hs, j, i)
                else:
                    rmsd = compute_rmsd(args.rmsd_func, mol_comparison, mol_reference, j, i)
                cost_matrix[index][j] = rmsd
        opt = scipy.optimize.linear_sum_assignment(cost_matrix)

        # Compute the fraction of recovered reference conformations within the comparison RMSD threshold(s):
        comparison_results = []
        for comparison_threshold in args.rmsd_threshold:
            num = 0
            for i in range(opt[0].shape[0]):
                if cost_matrix[opt[0][i], opt[1][i]] < comparison_threshold:
                    num += 1
            comparison_results.append((num / cost_matrix.shape[0])*100.0)

        results.append(comparison_results)

    return results


def compare_conformations(args: Args, logger: Logger) -> None:
    """
    Compare two sets of conformations generated by different conformational search programs.
    :param args: System arguments.
    :param logger: System logger.
    :return: None.
    """
    # Set up logger
    debug, info = logger.debug, logger.info

    # Define constants
    k_b = 3.297e-24  # Boltzmann constant in cal/K
    avogadro = 6.022e23

    debug(f'Loading conformations...')
    if args.group_comparison:
        conformation_sets = []
        for i in range(len(args.group_conf_paths)):
            # noinspection PyUnresolvedReferences
            conformation_sets.append(Chem.Mol(open(args.group_conf_paths[i], "rb").read()))
            debug(f'Conformation set {i} has {conformation_sets[i].GetNumConformers()} conformations')

        debug(f'Creating combined reference set...')
        mol_reference = copy.deepcopy(conformation_sets[0])
        count = mol_reference.GetNumConformers()
        for i in range(1, len(conformation_sets)):
            tmp = copy.deepcopy(conformation_sets[i])
            for j in range(tmp.GetNumConformers()):
                c = tmp.GetConformers()[j]
                c.SetId(count)
                mol_reference.AddConformer(c)
                count += 1

        debug(f'Computing reference energies...')
        reference_energies = []
        res = AllChem.MMFFOptimizeMoleculeConfs(mol_reference, maxIters=0, numThreads=0)
        for i in range(len(res)):
            reference_energies.append(res[i][1])

        debug(f'RMSD pruning of reference set...')
        mol_reference = rmsd_pruning(mol_reference, reference_energies, args.rmsd_func, args.rmsd_remove_Hs,
                                     args.energy_difference_threshold, args.rmsd_pruning_threshold)

        debug(f'Combined reference set has {mol_reference.GetNumConformers()} conformations')
    else:
        # noinspection PyUnresolvedReferences
        conformation_sets = [Chem.Mol(open(args.generated_path, "rb").read())]
        # noinspection PyUnresolvedReferences
        mol_reference = Chem.Mol(open(args.reference_path, "rb").read())

    debug(f'Computing finalized reference energies...')
    reference_energies = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol_reference, maxIters=0, numThreads=0)
    for i in range(len(res)):
        reference_energies.append(res[i][1])

    debug(f'Computing conformation probability hierarchy based on reference energies...')
    reference_probabilities = []
    # noinspection PyPep8Naming
    Z = 0
    # First, compute the partition function
    for i in range(len(reference_energies)):
        energy = reference_energies[i] * (1000.0 * 4.184 / avogadro)  # Convert from kcal/mol to Joules
        Z += math.exp(-energy/(k_b * args.temp * 4.184))

    # Second, compute the Boltzmann probabilities
    for i in range(len(reference_energies)):
        energy = reference_energies[i] * (1000.0 * 4.184 / avogadro)
        reference_probabilities.append(boltzmann_probability(energy, k_b, args.temp, Z))

    debug(f'Creating list of unique energy values...')
    unique_reference_energies = [reference_energies[0]]
    unique_reference_probabilities = [reference_probabilities[0]]
    for i in range(1, len(reference_energies)):
        unique = True
        for j in range(len(unique_reference_energies)):
            energy_diff = abs(reference_energies[i] - unique_reference_energies[j])
            if energy_diff < args.energy_difference_threshold:
                unique = False
                break
        if unique:
            unique_reference_energies.append(reference_energies[i])
            unique_reference_probabilities.append(reference_probabilities[i])

    reference_energy_minimum = min(reference_energies)
    debug(f'The reference set global energy minimum is: {reference_energy_minimum} kcal/mol')
    debug(f'The reference energy fractions checked for RMSD recovery are: {args.rmsd_recovery_fraction}')
    debug(f'The RMSD levels checked for recovery are (Angstrom): {args.rmsd_threshold}')

    # Create lists holding results info for plotting
    energy_plotting = []
    rmsd_results = []

    # Extract results for each conformation set
    debug(f'Comparing to reference set...')
    for i in tqdm(range(len(conformation_sets))):
        results = reference_comparison(mol_reference, reference_energies, unique_reference_energies,
                                       conformation_sets[i], i, args)
        energy_plotting += results[2]
        for index1, j in enumerate(args.rmsd_recovery_fraction):
            for index2, k in enumerate(results[3 + index1]):
                rmsd_results.append([args.rmsd_threshold[index2], j, k, args.group_conf_labels[i]])

    # Plot RMSD results and save dataframe
    df = pd.DataFrame(rmsd_results)
    df = df.rename(columns={0: 'RMSD Threshold', 1: 'Energy Fraction', 2: 'Percent Recovery', 3: 'Method'})
    df.to_pickle(os.path.join(args.save_dir, "rmsd-results.pkl"))

    sns.set_theme()
    for i in range(len(args.rmsd_threshold)):
        df_tmp = df[df['RMSD Threshold'] == args.rmsd_threshold[i]]
        fig, ax = plt.subplots()
        sns.lineplot(x='Energy Fraction', y='Percent Recovery', hue='Method', data=df_tmp)
        ax.set_xlabel("Fraction of lowest energy conformations")
        ax.set_ylabel("Percent structures recovered")
        ax.set_xlim(max(args.rmsd_recovery_fraction), min(args.rmsd_recovery_fraction))
        ax.set_ylim((0, 101))
        ax.figure.savefig(os.path.join(args.save_dir, f'rmsd-recovery-{args.rmsd_threshold[i]}-test.png'))
        plt.clf()
        plt.close()

    # Plot energy results and save dataframe
    sns.set_style('whitegrid')
    df = pd.DataFrame(energy_plotting)
    df = df.rename(columns={0: 'Energy', 1: 'Discovery', 2: 'Method'})
    df.to_pickle(os.path.join(args.save_dir, "energy-results.pkl"))
    try:
        fig = sns.catplot(x='Method', y='Energy', hue='Discovery', kind='swarm', data=df, s=5)
    except UserWarning:
        fig = sns.catplot(x='Method', y='Energy', hue='Discovery', data=df, s=2)
    fig.savefig(os.path.join(args.save_dir, "energy-values.png"))
    plt.clf()
    plt.close()

    # Compute energy below which 99.9% of conformation probability mass lies below
    cumsum = 0
    bulk = 0
    for i in range(len(reference_probabilities)):
        cumsum += reference_probabilities[i]
        if cumsum >= 0.999:
            bulk = reference_energies[i]
            break

    # Plot probabilities
    ax = sns.scatterplot(x=reference_energies, y=reference_probabilities, color="b")
    ax.set_xlabel("Energy (kcal/mol)")
    ax.set_ylabel("Probability")
    plt.axvline(x=bulk, linestyle="--", linewidth=0.5, color='r', label="99.9% probability mass")
    plt.legend()
    ax.figure.savefig(os.path.join(args.save_dir, "probabilities-vs-energies.png"))
    plt.clf()
    plt.close()
