""" Compare two sets of conformations generated by different conformational search programs. """
import copy
import math
import matplotlib.pyplot as plt
import numpy as np
import os
from typing import List

from rdkit import Chem
from rdkit.Chem import AllChem, rdMolAlign
import scipy.optimize
import seaborn as sns
# noinspection PyPackageRequirements
from tap import Tap
from tqdm import tqdm


class Args(Tap):
    """
    System arguments.
    """
    conf_path_1: str  # Path to binary file containing first set of conformations, the reference set
    conf_path_2: str  # Path to binary file containing second set of conformations, comparison set
    reference_energy_fraction: float = None  # Bottom fraction of conformers in terms of energy to compare to
    comparison_rmsd_threshold: List[float] = [0.5]  # RMSD threshold applied for comparing to reference
    rmsd_remove_Hs: bool = False  # Whether or not to remove Hydrogen when computing RMSD values via RDKit
    save_dir: str  # Save path for output files


def compare_conformations(args: Args):
    """
    Compare two sets of conformations generated by different conformational search programs.
    :param args: System arguments.
    :return: None.
    """
    os.makedirs(args.save_dir)

    # Load reference set and comparison set of conformations
    print(f'Loading conformation sets...')
    # noinspection PyUnresolvedReferences
    mol_reference = Chem.Mol(open(args.conf_path_1, "rb").read())
    mol_reference_no_hs = Chem.RemoveHs(mol_reference)
    print(f'Reference set has {mol_reference.GetNumConformers()} conformations')
    # noinspection PyUnresolvedReferences
    mol_comparison = Chem.Mol(open(args.conf_path_2, "rb").read())
    mol_comparison_no_hs = Chem.RemoveHs(mol_comparison)
    print(f'Comparison set has {mol_comparison.GetNumConformers()} conformations')

    # Compute energies for reference conformations
    print(f'Computing reference conformation energies...')
    reference_energies = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol_reference, maxIters=0, numThreads=0)
    for i in range(len(res)):
        reference_energies.append(res[i][1])

    # Compute energies for comparison conformations
    print(f'Computing comparison conformation energies...')
    comparison_energies = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol_comparison, maxIters=0, numThreads=0)
    for i in range(len(res)):
        comparison_energies.append(res[i][1])

    # Sort the energies and take the relevant fraction
    if args.reference_energy_fraction is not None:
        sorted_indices = sorted(range(len(reference_energies)), key=lambda k: reference_energies[k])
        fraction_indices = sorted_indices[:math.ceil(args.reference_energy_fraction*len(sorted_indices))]
        mol_reference_new = copy.deepcopy(mol_reference)
        mol_reference_new.RemoveAllConformers()
        for i, conf_num in enumerate(fraction_indices):
            c = mol_reference.GetConformers()[conf_num]
            c.SetId(i)
            mol_reference_new.AddConformer(c)
        mol_reference = mol_reference_new
        mol_reference_no_hs = Chem.RemoveHs(mol_reference)

        # Compute energies for reference conformations
        print(f'Recomputing reference conformation energies...')
        reference_energies = []
        res = AllChem.MMFFOptimizeMoleculeConfs(mol_reference, maxIters=0, numThreads=0)
        for i in range(len(res)):
            reference_energies.append(res[i][1])

    # Compute RMSD cost matrix between reference conformations and comparison conformations
    print(f'Computing RMSD cost matrix...')
    cost_matrix = np.zeros([mol_reference.GetNumConformers(), mol_comparison.GetNumConformers()])
    for i in tqdm(range(mol_reference.GetNumConformers())):
        for j in range(mol_comparison.GetNumConformers()):
            if args.rmsd_remove_Hs:
                rmsd = rdMolAlign.GetBestRMS(mol_comparison_no_hs, mol_reference_no_hs, j, i)
            else:
                rmsd = rdMolAlign.GetBestRMS(mol_comparison, mol_reference, j, i)
            cost_matrix[i][j] = rmsd
    opt = scipy.optimize.linear_sum_assignment(cost_matrix)

    print(f'Confab minimum: {min(reference_energies)}')
    print(f'MH minimum: {min(comparison_energies)}')
    # Compute the fraction of recovered reference conformations within the comparison RMSD threshold(s):
    comparison_results = []
    for comparison_threshold in args.comparison_rmsd_threshold:
        recovered_reference_energies = []
        num = 0
        for i in range(opt[0].shape[0]):
            if cost_matrix[opt[0][i], opt[1][i]] < comparison_threshold:
                recovered_reference_energies.append(reference_energies[opt[0][i]])
                num += 1
        print(f'Fraction of reference conformations recovered within RMSD threshold {comparison_threshold}: '
              f'{num / cost_matrix.shape[0]}')
        comparison_results.append([comparison_threshold, num / cost_matrix.shape[0]])

        # Plot histogram of reference energies simultaneously with histogram of recovered reference energies
        reference_energies = np.array(reference_energies)
        fig, ax = plt.subplots()
        bins = np.arange(min(reference_energies) - 1., max(reference_energies) + 1., 0.1)
        sns.histplot(reference_energies, ax=ax, bins=bins, color='b')
        if len(recovered_reference_energies) > 0:
            recovered_reference_energies = np.array(recovered_reference_energies)
            sns.histplot(recovered_reference_energies, ax=ax, bins=bins, color='r')
        ax.set_xlabel("Energy (kcal/mol)")
        ax.set_ylabel("Frequency")
        ax.figure.savefig(os.path.join(args.save_dir, "matched-distribution-RMSD-" +
                                       str(comparison_threshold) + ".png"))
        plt.clf()
        plt.close()
    comparison_results = np.array(comparison_results)
    np.save(os.path.join(args.save_dir, "comparison-results"), comparison_results)
