""" Compare two sets of conformations generated by different conformational search programs. """
import copy
from logging import Logger
import math
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import os
import pandas as pd
from typing import List, Tuple
from typing_extensions import Literal

from rdkit import Chem
from rdkit.Chem import AllChem, rdchem
import scipy.optimize
import seaborn as sns
# noinspection PyPackageRequirements
from tap import Tap
from tqdm import tqdm

from conformation.run_rmsd_pruning import compute_rmsd


class Args(Tap):
    """
    System arguments.
    """
    group_comparison: bool = False  # Whether or not to do a group comparison; default is reference comparison
    group_conf_paths: List[str] = []  # List of RDKit binary file paths to conformations for group comparison
    group_conf_labels: List[str] = []  # List of method labels for plotting purposes
    reference_path: str = None  # Path to RDKit binary file containing reference set (group_comparison=False)
    generated_path: str = None  # Path to RDKit binary file containing comparison set (group_comparison=False)
    energy_difference_threshold: float = 0.001  # Error tolerance for comparing energy values
    rmsd_pruning_threshold: float = 0.01  # Error tolerance for pruning reference set energies (group_comparison=True)
    rmsd_func: Literal["GetBestRMS", "AlignMol"] = "GetBestRMS"  # RMSD computation options
    rmsd_recovery_fraction: List[float] = [0.1]  # Bottom fraction of energies to check for recovery via RMSD
    rmsd_threshold: List[float] = [0.5]  # RMSD threshold applied
    rmsd_remove_Hs: bool = False  # Whether or not to remove Hydrogen when computing RMSD
    temp: float = 300.0  # Temperature at which to compute Boltzmann probabilities.
    energy_plot_size: float = 5  # Set marker size for energy value plot.
    reverse_energy_plot_axes: bool = False  # Whether or not to put categories on the y-axis.
    save_dir: str  # Save path for output files


# noinspection PyUnresolvedReferences
def plot_energy_probabilities(df: pd.DataFrame, ax=None) -> matplotlib.axes.Axes:
    """
    Plot conformation empirical probability vs energy.
    :param df: DataFrame whose columns are "Energy (kcal/mol)" and "Probability".
    :param ax: Matplotlib axes object.
    :return: Matplotlib axes object.
    """
    return sns.scatterplot(data=df, x='Energy (kcal/mol)', y='Probability', color="b", ax=ax)


def plot_energy_group_comparison(df: pd.DataFrame, reverse_axes: bool = False, size: float = 5.0) -> \
        sns.axisgrid.FacetGrid:
    """
    Plot energy level recovery for a group of conformation sets.
    :param df: DataFrame where the columns are Energy, Method, and Discovery. Energy is the energy level (kcal/mol),
    Method is a label for a sampler, and Discovery indicates whether or not a given Energy was found by a Method.
    :param reverse_axes: Whether or not to reverse axes, i.e., put Method on y-axis instead of x-axis.
    :param size: Plot marker size.
    :return: Seaborn FacetGrid.
    """
    if reverse_axes:
        fig = sns.catplot(x='Energy (kcal/mol)', y='Method', hue='Discovery', kind='swarm', data=df, s=size)
    else:
        fig = sns.catplot(x='Method', y='Energy (kcal/mol)', hue='Discovery', kind='swarm', data=df, s=size)

    return fig


# noinspection PyUnresolvedReferences
def plot_rmsd_group_comparison(df: pd.DataFrame, legend_fontsize: float = 5) -> matplotlib.figure.Figure:
    """
    Plot RMSD recovery for a group of conformation sets.
    :param df: DataFrame where the columns are RMSD Threshold, Energy Fraction, Percent Recovery, and Method.
    RMSD Threshold indicates the level below which conformations are considered equivalent, Energy Fraction is the
    fraction of lowest energy reference set conformations used to compute percent recovery, Percent Recovery is the
    percent of conformations within the given energy fraction achieved by a method, and a Method is a label for a
    conformation sampler.
    :param legend_fontsize: Fontsize for legend.
    :return: Matplotlib figure.
    """
    rmsd_thresholds = list(set(df['RMSD Threshold'].to_numpy()))
    rmsd_thresholds.sort()
    fig, axes = plt.subplots(len(rmsd_thresholds))
    max_rmsd_recovery_fraction, min_rmsd_recovery_fraction = max(df['Energy Fraction']), min(df['Energy Fraction'])
    for i in range(len(rmsd_thresholds)):
        df_tmp = df[df['RMSD Threshold'] == rmsd_thresholds[i]]
        ax = axes[i]
        if i == 0:
            sns.lineplot(x='Energy Fraction', y='Percent Recovery', hue='Method', data=df_tmp, ax=ax, legend=True)
            ax.legend(fontsize=legend_fontsize)
        else:
            sns.lineplot(x='Energy Fraction', y='Percent Recovery', hue='Method', data=df_tmp, ax=ax, legend=False)
        if i < len(rmsd_thresholds) - 1:
            ax.spines['bottom'].set_visible(False)
            ax.set(xticklabels=[])
            ax.set(xlabel=None)
        if i == len(rmsd_thresholds) - 1:
            ax.set_xlabel("Fraction of lowest energy conformations")
        ax.set_ylabel(f'% recovery @ {rmsd_thresholds[i]} $\AA$')
        ax.set_xlim(max_rmsd_recovery_fraction, min_rmsd_recovery_fraction)
        ax.set_ylim((0, 101))

    # return plots
    return fig


# noinspection PyUnresolvedReferences
def compute_energy_weights(mol: rdchem.Mol, temp: float = 293) -> np.ndarray:
    """
    Compute empirical Boltzmann probabilities of conformations.
    :param mol: RDKit Mol object containing conformations.
    :param temp: Temperature in K.
    :return: Array of empirical probabilities.
    """
    mol = Chem.Mol(mol)
    probabilities = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol, maxIters=0, numThreads=0)
    for i in range(len(res)):
        energy = res[i][1] * 1000.0 * 4.184 / 6.022e23  # Convert energy to Joules
        probabilities.append(math.exp(-energy / (3.297e-24 * temp * 4.184)))
    Z = sum(probabilities)  # Compute empirical partition function

    # Compute empirical probabilities
    for i in range(len(probabilities)):
        probabilities[i] /= Z
    probabilities = np.array(probabilities)

    return probabilities


# noinspection PyUnresolvedReferences,PyPep8Naming
def rmsd_pruning(mol: rdchem.Mol, rmsd_func: Literal["GetBestRMS", "AlignMol"], remove_Hs: bool,
                 energy_threshold: float, rmsd_threshold: float) -> rdchem.Mol:
    """
    RMSD pruning of RDKit conformations.
    :param mol: Mol object containing all conformations to be pruned.
    :param rmsd_func: Which RMSD function to use.
    :param remove_Hs: Whether or not to remove Hydrogen atoms for RMSD computation.
    :param energy_threshold: Energy threshold for determining if two conformations are different.
    :param rmsd_threshold: RMSD threshold for determining if two conformations are the same.
    :return: Mol object containing pruned conformations.
    """
    mol = Chem.Mol(mol)
    energies = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol, maxIters=0, numThreads=0)
    for i in range(len(res)):
        energies.append(res[i][1])

    unique_conformer_indices = []

    if remove_Hs:
        # noinspection PyPep8Naming
        mol_no_Hs = Chem.RemoveHs(mol)

    # Loop through conformations to find unique ones
    unique_conformer_indices.append(0)
    for i in tqdm(range(1, mol.GetNumConformers())):
        unique = True
        for j in unique_conformer_indices:
            energy_diff = abs(energies[i] - energies[j])
            if energy_diff < energy_threshold:
                if remove_Hs:
                    # noinspection PyUnboundLocalVariable
                    rmsd = compute_rmsd(rmsd_func, mol_no_Hs, mol_no_Hs, j, i)
                else:
                    rmsd = compute_rmsd(rmsd_func, mol, mol, j, i)
                if rmsd < rmsd_threshold:
                    unique = False
                    # Preserve lower energy conformation
                    if energies[i] < energies[j]:
                        unique_conformer_indices[unique_conformer_indices.index(j)] = i
                    break
        if unique:
            unique_conformer_indices.append(i)

    pruned_mol = copy.deepcopy(mol)
    pruned_mol.RemoveAllConformers()
    count = 0
    for i in unique_conformer_indices:
        c = mol.GetConformer(i)
        c.SetId(count)
        pruned_mol.AddConformer(c)
        count += 1

    return pruned_mol


# noinspection PyUnresolvedReferences
def reference_comparison(mol_reference: rdchem.Mol, reference_energies: List, unique_reference_energies: List,
                         mol_comparison: rdchem.Mol, comparison_id: int, energy_difference_threshold: float,
                         mol_labels: List[str], rmsd_recovery_fractions: List[float], rmsd_remove_Hs: bool,
                         rmsd_func: Literal["GetBestRMS", "AlignMol"], rmsd_thresholds: List[float]) -> List:
    """
    Compare two sets of conformations in terms of energy level recovery and RMSD recovery.
    :param mol_reference: Reference conformations.
    :param reference_energies: Reference energies.
    :param unique_reference_energies: Unique reference energies.
    :param mol_comparison: Comparison conformations.
    :param comparison_id: ID number for the comparison set.
    :param energy_difference_threshold: Error tolerance for comparing energy values.
    :param mol_labels: List of labels.
    :param rmsd_recovery_fractions: List of bottom fraction of energies to check for recovery via RMSD.
    :param rmsd_remove_Hs: Whether or not to remove Hydrogen when computing RMSD.
    :param rmsd_func: Which RMSD function to use for RMSD computation.
    :param rmsd_thresholds: List of RMSD thresholds to apply.
    :return: List of results.
    """
    results = []

    mol_reference_no_hs = Chem.RemoveHs(mol_reference)
    mol_comparison_no_hs = Chem.RemoveHs(mol_comparison)

    comparison_energies = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol_comparison, maxIters=0, numThreads=0)
    for i in range(len(res)):
        comparison_energies.append(res[i][1])

    # Produce information for energy level plotting
    cost_matrix = np.zeros([len(unique_reference_energies), len(comparison_energies)])
    for i in range(len(unique_reference_energies)):
        for j in range(len(comparison_energies)):
            energy_diff = abs(comparison_energies[j] - unique_reference_energies[i])
            cost_matrix[i][j] = energy_diff
    opt = scipy.optimize.linear_sum_assignment(cost_matrix)

    discovered_energies = []
    discovered_indices = []
    for i in range(opt[0].shape[0]):
        if cost_matrix[opt[0][i], opt[1][i]] < energy_difference_threshold:
            discovered_energies.append([unique_reference_energies[opt[0][i]], "Found", mol_labels[comparison_id]])
            discovered_indices.append(opt[0][i])
    for i in range(len(unique_reference_energies)):
        if i not in discovered_indices:
            discovered_energies.append([unique_reference_energies[i], "Not Found", mol_labels[comparison_id]])
    results.append(discovered_energies)

    # Produce information for RMSD threshold comparisons
    for fraction in rmsd_recovery_fractions:
        sorted_indices = sorted(range(len(reference_energies)), key=lambda k: reference_energies[k])
        fraction_indices = sorted_indices[:math.ceil(fraction * len(sorted_indices))]

        # Compute RMSD cost matrix between reference conformations and comparison conformations
        cost_matrix = np.zeros([len(fraction_indices), mol_comparison.GetNumConformers()])
        for index, i in enumerate(fraction_indices):
            for j in range(mol_comparison.GetNumConformers()):
                if rmsd_remove_Hs:
                    rmsd = compute_rmsd(rmsd_func, mol_comparison_no_hs, mol_reference_no_hs, j, i)
                else:
                    rmsd = compute_rmsd(rmsd_func, mol_comparison, mol_reference, j, i)
                cost_matrix[index][j] = rmsd
        opt = scipy.optimize.linear_sum_assignment(cost_matrix)

        # Compute the fraction of recovered reference conformations within the comparison RMSD threshold(s):
        comparison_results = []
        for comparison_threshold in rmsd_thresholds:
            num = 0
            for i in range(opt[0].shape[0]):
                if cost_matrix[opt[0][i], opt[1][i]] < comparison_threshold:
                    num += 1
            comparison_results.append((num / cost_matrix.shape[0]) * 100.0)

        results.append(comparison_results)

    return results


# noinspection PyUnresolvedReferences
def compute_conformation_group_comparison(mol_list: List[rdchem.Mol], mol_labels: List[str],
                                          rmsd_func: Literal["GetBestRMS", "AlignMol"], rmsd_remove_Hs: bool = False,
                                          energy_difference_threshold: float = 0.001,
                                          rmsd_pruning_threshold: float = 0.01,
                                          rmsd_recovery_fractions: List[float] = None,
                                          rmsd_thresholds: List[float] = None,
                                          temp: float = 293) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    """
    Compare energy level and RMSD recovery for multiple sets of conformations. A combined reference set is generated
    from the multiple conformation sets and is used to compute energy and RMSD recovery.
    :param mol_list: List of RDKit mol objects containing conformations.
    :param mol_labels: List of labels for each molecule in the mol_list.
    :param rmsd_func: Which RMSD function to use for RMSD computation.
    :param rmsd_remove_Hs: Whether or not to remove Hydrogen when computing RMSD.
    :param energy_difference_threshold: Error tolerance for comparing energy values. When two energies are within this
    tolerance, they are considered to be the same energy level.
    :param rmsd_pruning_threshold: RMSD threshold for determining if two conformations are the same.
    :param rmsd_recovery_fractions: List of bottom fraction of energies to check for recovery via RMSD.
    :param rmsd_thresholds: List of RMSD thresholds to apply.
    :param temp: Temperature at which to compute Boltzmann probabilities.
    :return: Three DataFrames. The first contains energy results where the columns are Energy, Method, and Discovery.
    Energy is the energy level (kcal/mol), Method is a label for a sampler, and Discovery indicates whether or not a
    given Energy was found by a Method. The second contains RMSD results where the columns are RMSD Threshold,
    Energy Fraction, Percent Recovery, and Method. RMSD Threshold indicates the level below which conformations are
    considered equivalent, Energy Fraction is the fraction of lowest energy reference set conformations used to compute
    percent recovery, Percent Recovery is the percent of conformations within the given energy fraction achieved by a
    method, and a Method is a label for a conformation sampler. The third contains two columns, reference
    set conformation energies and reference set conformation probabilities.
    """

    if rmsd_thresholds is None:
        rmsd_thresholds = [0.2, 1.0]
    if rmsd_recovery_fractions is None:
        rmsd_recovery_fractions = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]

    # Create a combined reference set
    mol_reference = copy.deepcopy(mol_list[0])
    count = mol_reference.GetNumConformers()
    for i in range(1, len(mol_list)):
        tmp = copy.deepcopy(mol_list[i])
        for j in range(tmp.GetNumConformers()):
            c = tmp.GetConformers()[j]
            c.SetId(count)
            mol_reference.AddConformer(c)
            count += 1

    # RMSD pruning of reference set
    mol_reference = rmsd_pruning(mol_reference, rmsd_func, rmsd_remove_Hs, energy_difference_threshold,
                                 rmsd_pruning_threshold)

    print(f'Combined reference set has {mol_reference.GetNumConformers()} conformations')

    # Compute reference set energies
    reference_energies = []
    res = AllChem.MMFFOptimizeMoleculeConfs(mol_reference, maxIters=0, numThreads=0)
    for i in range(len(res)):
        reference_energies.append(res[i][1])

    print(f'The reference set global energy minimum is: {min(reference_energies)} kcal/mol')

    # Compute reference energies and probabilities
    reference_probabilities = compute_energy_weights(mol_reference, temp)

    # Compute reference energy levels
    unique_reference_energies = [reference_energies[0]]
    for i in range(1, len(reference_energies)):
        unique = True
        for j in range(len(unique_reference_energies)):
            energy_diff = abs(reference_energies[i] - unique_reference_energies[j])
            if energy_diff < energy_difference_threshold:
                unique = False
                break
        if unique:
            unique_reference_energies.append(reference_energies[i])

    # Create lists holding results info for plotting
    energy_results = []
    rmsd_results = []

    print("Analyzing each conformation set against the combined reference...")
    for i in tqdm(range(len(mol_list))):
        results = reference_comparison(mol_reference, reference_energies, unique_reference_energies, mol_list[i], i,
                                       energy_difference_threshold, mol_labels, rmsd_recovery_fractions,
                                       rmsd_remove_Hs, rmsd_func, rmsd_thresholds)
        energy_results += results[0]
        for j, fraction in enumerate(rmsd_recovery_fractions):
            for k, recovery in enumerate(results[1 + j]):
                rmsd_results.append([rmsd_thresholds[k], fraction, recovery, mol_labels[i]])

    # Create RMSD results dataframe
    df_rmsd = pd.DataFrame(rmsd_results)
    df_rmsd = df_rmsd.rename(columns={0: 'RMSD Threshold', 1: 'Energy Fraction', 2: 'Percent Recovery', 3: 'Method'})

    # Create energy results dataframe
    df_energy = pd.DataFrame(energy_results)
    df_energy = df_energy.rename(columns={0: 'Energy (kcal/mol)', 1: 'Discovery', 2: 'Method'})

    # Create reference set energies and probabilities dataframe
    df_prob = pd.DataFrame(np.concatenate((np.array(reference_energies)[:, np.newaxis],
                                           reference_probabilities[:, np.newaxis]), axis=1))
    df_prob = df_prob.rename(columns={0: 'Energy (kcal/mol)', 1: 'Probability'})

    return df_energy, df_rmsd, df_prob


def compare_conformations(args: Args, logger: Logger) -> None:
    """
    Compare two sets of conformations generated by different conformational search programs.
    :param args: System arguments.
    :param logger: System logger.
    :return: None.
    """
    # Set up logger
    debug, info = logger.debug, logger.info

    conformation_sets = []
    for i in range(len(args.group_conf_paths)):
        # noinspection PyUnresolvedReferences
        conformation_sets.append(Chem.Mol(open(args.group_conf_paths[i], "rb").read()))
        debug(f'Conformation set {i} has {conformation_sets[i].GetNumConformers()} conformations')

    df_energy, df_rmsd, df_prob = compute_conformation_group_comparison(
        conformation_sets,
        args.group_conf_labels,
        "GetBestRMS",
        True,
        rmsd_thresholds=args.rmsd_threshold,
        rmsd_recovery_fractions=args.rmsd_recovery_fraction)

    sns.set_theme()
    sns.set(font_scale=0.3)
    fig = plot_rmsd_group_comparison(df_rmsd)
    fig.savefig(os.path.join(args.save_dir, f'rmsd-recovery.png'), dpi=200)
    plt.clf()
    plt.close()
    sns.set_theme()

    # Plot energy results and save dataframe
    sns.set_style('whitegrid')
    fig = plot_energy_group_comparison(df_energy, args.reverse_energy_plot_axes, args.energy_plot_size)
    fig.savefig(os.path.join(args.save_dir, "energy-values.png"))
    plt.clf()
    plt.close()

    # Plot probabilities
    ax = plot_energy_probabilities(df_prob)
    ax.figure.savefig(os.path.join(args.save_dir, "probabilities-vs-energies.png"))
    plt.clf()
    plt.close()
